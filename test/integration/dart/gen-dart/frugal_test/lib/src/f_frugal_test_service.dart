// Autogenerated by Frugal Compiler (3.9.7)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING



// ignore_for_file: unused_import
// ignore_for_file: unused_field
import 'dart:async';
import 'dart:typed_data' show Uint8List;

import 'package:collection/collection.dart';
import 'package:logging/logging.dart' as logging;
import 'package:thrift/thrift.dart' as thrift;
import 'package:frugal/frugal.dart' as frugal;
import 'package:w_common/disposable.dart' as disposable;

import 'package:frugal_test/frugal_test.dart' as t_frugal_test;


abstract class FFrugalTest {
  Future testVoid(frugal.FContext ctx);

  Future<String> testString(frugal.FContext ctx, String thing);

  /// Deprecated: use something else
  @deprecated
  Future<bool> testBool(frugal.FContext ctx, bool thing);

  Future<int> testByte(frugal.FContext ctx, int thing);

  Future<int> testI32(frugal.FContext ctx, int thing);

  Future<int> testI64(frugal.FContext ctx, int thing);

  Future<double> testDouble(frugal.FContext ctx, double thing);

  Future<Uint8List> testBinary(frugal.FContext ctx, Uint8List thing);

  Future<t_frugal_test.Xtruct> testStruct(frugal.FContext ctx, t_frugal_test.Xtruct thing);

  Future<t_frugal_test.Xtruct2> testNest(frugal.FContext ctx, t_frugal_test.Xtruct2 thing);

  Future<Map<int, int>> testMap(frugal.FContext ctx, Map<int, int> thing);

  Future<Map<String, String>> testStringMap(frugal.FContext ctx, Map<String, String> thing);

  Future<Set<int>> testSet(frugal.FContext ctx, Set<int> thing);

  Future<List<int>> testList(frugal.FContext ctx, List<int> thing);

  Future<int> testEnum(frugal.FContext ctx, int thing);

  Future<int> testTypedef(frugal.FContext ctx, int thing);

  Future<Map<int, Map<int, int>>> testMapMap(frugal.FContext ctx, int hello);

  Future<bool> testUppercaseMethod(frugal.FContext ctx, bool thing);

  Future<Map<int, Map<int, t_frugal_test.Insanity>>> testInsanity(frugal.FContext ctx, t_frugal_test.Insanity argument);

  Future<t_frugal_test.Xtruct> testMulti(frugal.FContext ctx, int arg0, int arg1, int arg2, Map<int, String> arg3, int arg4, int arg5);

  Future testException(frugal.FContext ctx, String arg);

  Future<t_frugal_test.Xtruct> testMultiException(frugal.FContext ctx, String arg0, String arg1);

  Future testUncaughtException(frugal.FContext ctx);

  Future testUncheckedTApplicationException(frugal.FContext ctx);

  Future testRequestTooLarge(frugal.FContext ctx, Uint8List request);

  Future<Uint8List> testResponseTooLarge(frugal.FContext ctx, Uint8List request);

  Future testOneway(frugal.FContext ctx, int millisecondsToSleep);
}

FFrugalTestClient fFrugalTestClientFactory(frugal.FServiceProvider provider, {List<frugal.Middleware> middleware}) =>
    FFrugalTestClient(provider, middleware);

class FFrugalTestClient extends disposable.Disposable implements FFrugalTest {
  static final logging.Logger _frugalLog = logging.Logger('FrugalTest');
  Map<String, frugal.FMethod> _methods;

  FFrugalTestClient(frugal.FServiceProvider provider, [List<frugal.Middleware> middleware])
      : this._provider = provider {
    _transport = provider.transport;
    _protocolFactory = provider.protocolFactory;
    var combined = middleware ?? [];
    combined.addAll(provider.middleware);
    this._methods = {};
    this._methods['testVoid'] = frugal.FMethod(this._testVoid, 'FrugalTest', 'testVoid', combined);
    this._methods['testString'] = frugal.FMethod(this._testString, 'FrugalTest', 'testString', combined);
    this._methods['testBool'] = frugal.FMethod(this._testBool, 'FrugalTest', 'testBool', combined);
    this._methods['testByte'] = frugal.FMethod(this._testByte, 'FrugalTest', 'testByte', combined);
    this._methods['testI32'] = frugal.FMethod(this._testI32, 'FrugalTest', 'testI32', combined);
    this._methods['testI64'] = frugal.FMethod(this._testI64, 'FrugalTest', 'testI64', combined);
    this._methods['testDouble'] = frugal.FMethod(this._testDouble, 'FrugalTest', 'testDouble', combined);
    this._methods['testBinary'] = frugal.FMethod(this._testBinary, 'FrugalTest', 'testBinary', combined);
    this._methods['testStruct'] = frugal.FMethod(this._testStruct, 'FrugalTest', 'testStruct', combined);
    this._methods['testNest'] = frugal.FMethod(this._testNest, 'FrugalTest', 'testNest', combined);
    this._methods['testMap'] = frugal.FMethod(this._testMap, 'FrugalTest', 'testMap', combined);
    this._methods['testStringMap'] = frugal.FMethod(this._testStringMap, 'FrugalTest', 'testStringMap', combined);
    this._methods['testSet'] = frugal.FMethod(this._testSet, 'FrugalTest', 'testSet', combined);
    this._methods['testList'] = frugal.FMethod(this._testList, 'FrugalTest', 'testList', combined);
    this._methods['testEnum'] = frugal.FMethod(this._testEnum, 'FrugalTest', 'testEnum', combined);
    this._methods['testTypedef'] = frugal.FMethod(this._testTypedef, 'FrugalTest', 'testTypedef', combined);
    this._methods['testMapMap'] = frugal.FMethod(this._testMapMap, 'FrugalTest', 'testMapMap', combined);
    this._methods['testUppercaseMethod'] = frugal.FMethod(this._testUppercaseMethod, 'FrugalTest', 'testUppercaseMethod', combined);
    this._methods['testInsanity'] = frugal.FMethod(this._testInsanity, 'FrugalTest', 'testInsanity', combined);
    this._methods['testMulti'] = frugal.FMethod(this._testMulti, 'FrugalTest', 'testMulti', combined);
    this._methods['testException'] = frugal.FMethod(this._testException, 'FrugalTest', 'testException', combined);
    this._methods['testMultiException'] = frugal.FMethod(this._testMultiException, 'FrugalTest', 'testMultiException', combined);
    this._methods['testUncaughtException'] = frugal.FMethod(this._testUncaughtException, 'FrugalTest', 'testUncaughtException', combined);
    this._methods['testUncheckedTApplicationException'] = frugal.FMethod(this._testUncheckedTApplicationException, 'FrugalTest', 'testUncheckedTApplicationException', combined);
    this._methods['testRequestTooLarge'] = frugal.FMethod(this._testRequestTooLarge, 'FrugalTest', 'testRequestTooLarge', combined);
    this._methods['testResponseTooLarge'] = frugal.FMethod(this._testResponseTooLarge, 'FrugalTest', 'testResponseTooLarge', combined);
    this._methods['testOneway'] = frugal.FMethod(this._testOneway, 'FrugalTest', 'testOneway', combined);
  }

  frugal.FServiceProvider _provider;
  frugal.FTransport _transport;
  frugal.FProtocolFactory _protocolFactory;

  @override
  Future<Null> onDispose() async {
    if (_provider is disposable.Disposable && !_provider.isOrWillBeDisposed)  {
      return _provider.dispose();
    }
    return null;
  }

  @override
  Future testVoid(frugal.FContext ctx) {
    return this._methods['testVoid']([ctx]);
  }

  Future _testVoid(frugal.FContext ctx) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testVoid', thrift.TMessageType.CALL, 0));
    testVoid_args args = testVoid_args();
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testVoid_result result = testVoid_result();
    result.read(iprot);
    iprot.readMessageEnd();
  }
  @override
  Future<String> testString(frugal.FContext ctx, String thing) {
    return this._methods['testString']([ctx, thing]).then((value) => value as String);
  }

  Future<String> _testString(frugal.FContext ctx, String thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testString', thrift.TMessageType.CALL, 0));
    testString_args args = testString_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testString_result result = testString_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testString failed: unknown result'
    );
  }
  /// Deprecated: use something else
  @deprecated
  @override
  Future<bool> testBool(frugal.FContext ctx, bool thing) {
    _frugalLog.warning("Call to deprecated function 'FrugalTest.testBool'");
    return this._methods['testBool']([ctx, thing]).then((value) => value as bool);
  }

  Future<bool> _testBool(frugal.FContext ctx, bool thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testBool', thrift.TMessageType.CALL, 0));
    testBool_args args = testBool_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testBool_result result = testBool_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testBool failed: unknown result'
    );
  }
  @override
  Future<int> testByte(frugal.FContext ctx, int thing) {
    return this._methods['testByte']([ctx, thing]).then((value) => value as int);
  }

  Future<int> _testByte(frugal.FContext ctx, int thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testByte', thrift.TMessageType.CALL, 0));
    testByte_args args = testByte_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testByte_result result = testByte_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testByte failed: unknown result'
    );
  }
  @override
  Future<int> testI32(frugal.FContext ctx, int thing) {
    return this._methods['testI32']([ctx, thing]).then((value) => value as int);
  }

  Future<int> _testI32(frugal.FContext ctx, int thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testI32', thrift.TMessageType.CALL, 0));
    testI32_args args = testI32_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testI32_result result = testI32_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testI32 failed: unknown result'
    );
  }
  @override
  Future<int> testI64(frugal.FContext ctx, int thing) {
    return this._methods['testI64']([ctx, thing]).then((value) => value as int);
  }

  Future<int> _testI64(frugal.FContext ctx, int thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testI64', thrift.TMessageType.CALL, 0));
    testI64_args args = testI64_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testI64_result result = testI64_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testI64 failed: unknown result'
    );
  }
  @override
  Future<double> testDouble(frugal.FContext ctx, double thing) {
    return this._methods['testDouble']([ctx, thing]).then((value) => value as double);
  }

  Future<double> _testDouble(frugal.FContext ctx, double thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testDouble', thrift.TMessageType.CALL, 0));
    testDouble_args args = testDouble_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testDouble_result result = testDouble_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testDouble failed: unknown result'
    );
  }
  @override
  Future<Uint8List> testBinary(frugal.FContext ctx, Uint8List thing) {
    return this._methods['testBinary']([ctx, thing]).then((value) => value as Uint8List);
  }

  Future<Uint8List> _testBinary(frugal.FContext ctx, Uint8List thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testBinary', thrift.TMessageType.CALL, 0));
    testBinary_args args = testBinary_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testBinary_result result = testBinary_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testBinary failed: unknown result'
    );
  }
  @override
  Future<t_frugal_test.Xtruct> testStruct(frugal.FContext ctx, t_frugal_test.Xtruct thing) {
    return this._methods['testStruct']([ctx, thing]).then((value) => value as t_frugal_test.Xtruct);
  }

  Future<t_frugal_test.Xtruct> _testStruct(frugal.FContext ctx, t_frugal_test.Xtruct thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testStruct', thrift.TMessageType.CALL, 0));
    testStruct_args args = testStruct_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testStruct_result result = testStruct_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testStruct failed: unknown result'
    );
  }
  @override
  Future<t_frugal_test.Xtruct2> testNest(frugal.FContext ctx, t_frugal_test.Xtruct2 thing) {
    return this._methods['testNest']([ctx, thing]).then((value) => value as t_frugal_test.Xtruct2);
  }

  Future<t_frugal_test.Xtruct2> _testNest(frugal.FContext ctx, t_frugal_test.Xtruct2 thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testNest', thrift.TMessageType.CALL, 0));
    testNest_args args = testNest_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testNest_result result = testNest_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testNest failed: unknown result'
    );
  }
  @override
  Future<Map<int, int>> testMap(frugal.FContext ctx, Map<int, int> thing) {
    return this._methods['testMap']([ctx, thing]).then((value) => value as Map<int, int>);
  }

  Future<Map<int, int>> _testMap(frugal.FContext ctx, Map<int, int> thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testMap', thrift.TMessageType.CALL, 0));
    testMap_args args = testMap_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testMap_result result = testMap_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testMap failed: unknown result'
    );
  }
  @override
  Future<Map<String, String>> testStringMap(frugal.FContext ctx, Map<String, String> thing) {
    return this._methods['testStringMap']([ctx, thing]).then((value) => value as Map<String, String>);
  }

  Future<Map<String, String>> _testStringMap(frugal.FContext ctx, Map<String, String> thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testStringMap', thrift.TMessageType.CALL, 0));
    testStringMap_args args = testStringMap_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testStringMap_result result = testStringMap_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testStringMap failed: unknown result'
    );
  }
  @override
  Future<Set<int>> testSet(frugal.FContext ctx, Set<int> thing) {
    return this._methods['testSet']([ctx, thing]).then((value) => value as Set<int>);
  }

  Future<Set<int>> _testSet(frugal.FContext ctx, Set<int> thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testSet', thrift.TMessageType.CALL, 0));
    testSet_args args = testSet_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testSet_result result = testSet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testSet failed: unknown result'
    );
  }
  @override
  Future<List<int>> testList(frugal.FContext ctx, List<int> thing) {
    return this._methods['testList']([ctx, thing]).then((value) => value as List<int>);
  }

  Future<List<int>> _testList(frugal.FContext ctx, List<int> thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testList', thrift.TMessageType.CALL, 0));
    testList_args args = testList_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testList_result result = testList_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testList failed: unknown result'
    );
  }
  @override
  Future<int> testEnum(frugal.FContext ctx, int thing) {
    return this._methods['testEnum']([ctx, thing]).then((value) => value as int);
  }

  Future<int> _testEnum(frugal.FContext ctx, int thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testEnum', thrift.TMessageType.CALL, 0));
    testEnum_args args = testEnum_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testEnum_result result = testEnum_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testEnum failed: unknown result'
    );
  }
  @override
  Future<int> testTypedef(frugal.FContext ctx, int thing) {
    return this._methods['testTypedef']([ctx, thing]).then((value) => value as int);
  }

  Future<int> _testTypedef(frugal.FContext ctx, int thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testTypedef', thrift.TMessageType.CALL, 0));
    testTypedef_args args = testTypedef_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testTypedef_result result = testTypedef_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testTypedef failed: unknown result'
    );
  }
  @override
  Future<Map<int, Map<int, int>>> testMapMap(frugal.FContext ctx, int hello) {
    return this._methods['testMapMap']([ctx, hello]).then((value) => value as Map<int, Map<int, int>>);
  }

  Future<Map<int, Map<int, int>>> _testMapMap(frugal.FContext ctx, int hello) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testMapMap', thrift.TMessageType.CALL, 0));
    testMapMap_args args = testMapMap_args();
    args.hello = hello;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testMapMap_result result = testMapMap_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testMapMap failed: unknown result'
    );
  }
  @override
  Future<bool> testUppercaseMethod(frugal.FContext ctx, bool thing) {
    return this._methods['testUppercaseMethod']([ctx, thing]).then((value) => value as bool);
  }

  Future<bool> _testUppercaseMethod(frugal.FContext ctx, bool thing) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testUppercaseMethod', thrift.TMessageType.CALL, 0));
    TestUppercaseMethod_args args = TestUppercaseMethod_args();
    args.thing = thing;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    TestUppercaseMethod_result result = TestUppercaseMethod_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testUppercaseMethod failed: unknown result'
    );
  }
  @override
  Future<Map<int, Map<int, t_frugal_test.Insanity>>> testInsanity(frugal.FContext ctx, t_frugal_test.Insanity argument) {
    return this._methods['testInsanity']([ctx, argument]).then((value) => value as Map<int, Map<int, t_frugal_test.Insanity>>);
  }

  Future<Map<int, Map<int, t_frugal_test.Insanity>>> _testInsanity(frugal.FContext ctx, t_frugal_test.Insanity argument) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testInsanity', thrift.TMessageType.CALL, 0));
    testInsanity_args args = testInsanity_args();
    args.argument = argument;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testInsanity_result result = testInsanity_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testInsanity failed: unknown result'
    );
  }
  @override
  Future<t_frugal_test.Xtruct> testMulti(frugal.FContext ctx, int arg0, int arg1, int arg2, Map<int, String> arg3, int arg4, int arg5) {
    return this._methods['testMulti']([ctx, arg0, arg1, arg2, arg3, arg4, arg5]).then((value) => value as t_frugal_test.Xtruct);
  }

  Future<t_frugal_test.Xtruct> _testMulti(frugal.FContext ctx, int arg0, int arg1, int arg2, Map<int, String> arg3, int arg4, int arg5) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testMulti', thrift.TMessageType.CALL, 0));
    testMulti_args args = testMulti_args();
    args.arg0 = arg0;
    args.arg1 = arg1;
    args.arg2 = arg2;
    args.arg3 = arg3;
    args.arg4 = arg4;
    args.arg5 = arg5;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testMulti_result result = testMulti_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testMulti failed: unknown result'
    );
  }
  @override
  Future testException(frugal.FContext ctx, String arg) {
    return this._methods['testException']([ctx, arg]);
  }

  Future _testException(frugal.FContext ctx, String arg) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testException', thrift.TMessageType.CALL, 0));
    testException_args args = testException_args();
    args.arg = arg;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testException_result result = testException_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.err1 != null) {
      throw result.err1;
    }
  }
  @override
  Future<t_frugal_test.Xtruct> testMultiException(frugal.FContext ctx, String arg0, String arg1) {
    return this._methods['testMultiException']([ctx, arg0, arg1]).then((value) => value as t_frugal_test.Xtruct);
  }

  Future<t_frugal_test.Xtruct> _testMultiException(frugal.FContext ctx, String arg0, String arg1) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testMultiException', thrift.TMessageType.CALL, 0));
    testMultiException_args args = testMultiException_args();
    args.arg0 = arg0;
    args.arg1 = arg1;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testMultiException_result result = testMultiException_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.err1 != null) {
      throw result.err1;
    }
    if (result.err2 != null) {
      throw result.err2;
    }
    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testMultiException failed: unknown result'
    );
  }
  @override
  Future testUncaughtException(frugal.FContext ctx) {
    return this._methods['testUncaughtException']([ctx]);
  }

  Future _testUncaughtException(frugal.FContext ctx) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testUncaughtException', thrift.TMessageType.CALL, 0));
    testUncaughtException_args args = testUncaughtException_args();
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testUncaughtException_result result = testUncaughtException_result();
    result.read(iprot);
    iprot.readMessageEnd();
  }
  @override
  Future testUncheckedTApplicationException(frugal.FContext ctx) {
    return this._methods['testUncheckedTApplicationException']([ctx]);
  }

  Future _testUncheckedTApplicationException(frugal.FContext ctx) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testUncheckedTApplicationException', thrift.TMessageType.CALL, 0));
    testUncheckedTApplicationException_args args = testUncheckedTApplicationException_args();
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testUncheckedTApplicationException_result result = testUncheckedTApplicationException_result();
    result.read(iprot);
    iprot.readMessageEnd();
  }
  @override
  Future testRequestTooLarge(frugal.FContext ctx, Uint8List request) {
    return this._methods['testRequestTooLarge']([ctx, request]);
  }

  Future _testRequestTooLarge(frugal.FContext ctx, Uint8List request) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testRequestTooLarge', thrift.TMessageType.CALL, 0));
    testRequestTooLarge_args args = testRequestTooLarge_args();
    args.request = request;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testRequestTooLarge_result result = testRequestTooLarge_result();
    result.read(iprot);
    iprot.readMessageEnd();
  }
  @override
  Future<Uint8List> testResponseTooLarge(frugal.FContext ctx, Uint8List request) {
    return this._methods['testResponseTooLarge']([ctx, request]).then((value) => value as Uint8List);
  }

  Future<Uint8List> _testResponseTooLarge(frugal.FContext ctx, Uint8List request) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testResponseTooLarge', thrift.TMessageType.CALL, 0));
    testResponseTooLarge_args args = testResponseTooLarge_args();
    args.request = request;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw thrift.TTransportError(
            frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    testResponseTooLarge_result result = testResponseTooLarge_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, 'testResponseTooLarge failed: unknown result'
    );
  }
  @override
  Future testOneway(frugal.FContext ctx, int millisecondsToSleep) {
    return this._methods['testOneway']([ctx, millisecondsToSleep]);
  }

  Future _testOneway(frugal.FContext ctx, int millisecondsToSleep) async {
    var memoryBuffer = frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(thrift.TMessage('testOneway', thrift.TMessageType.ONEWAY, 0));
    testOneway_args args = testOneway_args();
    args.millisecondsToSleep = millisecondsToSleep;
    args.write(oprot);
    oprot.writeMessageEnd();
    await _transport.oneway(ctx, memoryBuffer.writeBytes);
  }

}

// ignore: camel_case_types
class testVoid_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testVoid_args');



  testVoid_args();

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testVoid_args(');

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    return o is testVoid_args;
  }

  @override
  int get hashCode {
    var value = 17;
    return value;
  }

  testVoid_args clone() {
    return testVoid_args();
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testVoid_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testVoid_result');



  testVoid_result();

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testVoid_result(');

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    return o is testVoid_result;
  }

  @override
  int get hashCode {
    var value = 17;
    return value;
  }

  testVoid_result clone() {
    return testVoid_result();
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testString_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testString_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.STRING, 1);

  String _thing;
  static const int THING = 1;


  testString_args();

  String get thing => this._thing;

  set thing(String thing) {
    this._thing = thing;
  }

  bool isSetThing() => this.thing != null;

  unsetThing() {
    this.thing = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as String;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.STRING) {
            this.thing = iprot.readString();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.thing != null) {
      oprot.writeFieldBegin(_THING_FIELD_DESC);
      oprot.writeString(this.thing);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testString_args(');

    ret.write('thing:');
    if (this.thing == null) {
      ret.write('null');
    } else {
      ret.write(this.thing);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testString_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testString_args clone({
    String thing,
  }) {
    return testString_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
    if (this.thing == null) {
      throw thrift.TProtocolError(thrift.TProtocolErrorType.INVALID_DATA, "Required field 'thing' was not present in struct testString_args");
    }
  }
}
// ignore: camel_case_types
class testString_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testString_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.STRING, 0);

  String _success;
  static const int SUCCESS = 0;


  testString_result();

  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as String;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.STRING) {
            this.success = iprot.readString();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testString_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testString_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testString_result clone({
    String success,
  }) {
    return testString_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testBool_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testBool_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.BOOL, 1);

  bool _thing = false;
  static const int THING = 1;

  bool __isset_thing = false;

  testBool_args();

  bool get thing => this._thing;

  set thing(bool thing) {
    this._thing = thing;
    this.__isset_thing = true;
  }

  bool isSetThing() => this.__isset_thing;

  unsetThing() {
    this.__isset_thing = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as bool;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.BOOL) {
            this.thing = iprot.readBool();
            this.__isset_thing = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_THING_FIELD_DESC);
    oprot.writeBool(this.thing);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testBool_args(');

    ret.write('thing:');
    ret.write(this.thing);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testBool_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testBool_args clone({
    bool thing,
  }) {
    return testBool_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testBool_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testBool_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.BOOL, 0);

  bool _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  testBool_result();

  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as bool;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testBool_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      ret.write(this.success);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testBool_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testBool_result clone({
    bool success,
  }) {
    return testBool_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testByte_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testByte_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.BYTE, 1);

  int _thing = 0;
  static const int THING = 1;

  bool __isset_thing = false;

  testByte_args();

  int get thing => this._thing;

  set thing(int thing) {
    this._thing = thing;
    this.__isset_thing = true;
  }

  bool isSetThing() => this.__isset_thing;

  unsetThing() {
    this.__isset_thing = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.BYTE) {
            this.thing = iprot.readByte();
            this.__isset_thing = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_THING_FIELD_DESC);
    oprot.writeByte(this.thing);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testByte_args(');

    ret.write('thing:');
    ret.write(this.thing);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testByte_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testByte_args clone({
    int thing,
  }) {
    return testByte_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testByte_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testByte_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.BYTE, 0);

  int _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  testByte_result();

  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.BYTE) {
            this.success = iprot.readByte();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeByte(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testByte_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      ret.write(this.success);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testByte_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testByte_result clone({
    int success,
  }) {
    return testByte_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testI32_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testI32_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.I32, 1);

  int _thing = 0;
  static const int THING = 1;

  bool __isset_thing = false;

  testI32_args();

  int get thing => this._thing;

  set thing(int thing) {
    this._thing = thing;
    this.__isset_thing = true;
  }

  bool isSetThing() => this.__isset_thing;

  unsetThing() {
    this.__isset_thing = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.I32) {
            this.thing = iprot.readI32();
            this.__isset_thing = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_THING_FIELD_DESC);
    oprot.writeI32(this.thing);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testI32_args(');

    ret.write('thing:');
    ret.write(this.thing);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testI32_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testI32_args clone({
    int thing,
  }) {
    return testI32_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testI32_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testI32_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.I32, 0);

  int _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  testI32_result();

  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testI32_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      ret.write(this.success);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testI32_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testI32_result clone({
    int success,
  }) {
    return testI32_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testI64_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testI64_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.I64, 1);

  int _thing = 0;
  static const int THING = 1;

  bool __isset_thing = false;

  testI64_args();

  int get thing => this._thing;

  set thing(int thing) {
    this._thing = thing;
    this.__isset_thing = true;
  }

  bool isSetThing() => this.__isset_thing;

  unsetThing() {
    this.__isset_thing = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.I64) {
            this.thing = iprot.readI64();
            this.__isset_thing = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_THING_FIELD_DESC);
    oprot.writeI64(this.thing);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testI64_args(');

    ret.write('thing:');
    ret.write(this.thing);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testI64_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testI64_args clone({
    int thing,
  }) {
    return testI64_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testI64_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testI64_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.I64, 0);

  int _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  testI64_result();

  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testI64_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      ret.write(this.success);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testI64_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testI64_result clone({
    int success,
  }) {
    return testI64_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testDouble_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testDouble_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.DOUBLE, 1);

  double _thing = 0.0;
  static const int THING = 1;

  bool __isset_thing = false;

  testDouble_args();

  double get thing => this._thing;

  set thing(double thing) {
    this._thing = thing;
    this.__isset_thing = true;
  }

  bool isSetThing() => this.__isset_thing;

  unsetThing() {
    this.__isset_thing = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as double;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.DOUBLE) {
            this.thing = iprot.readDouble();
            this.__isset_thing = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_THING_FIELD_DESC);
    oprot.writeDouble(this.thing);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testDouble_args(');

    ret.write('thing:');
    ret.write(this.thing);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testDouble_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testDouble_args clone({
    double thing,
  }) {
    return testDouble_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testDouble_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testDouble_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.DOUBLE, 0);

  double _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  testDouble_result();

  double get success => this._success;

  set success(double success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as double;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.DOUBLE) {
            this.success = iprot.readDouble();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeDouble(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testDouble_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      ret.write(this.success);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testDouble_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testDouble_result clone({
    double success,
  }) {
    return testDouble_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testBinary_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testBinary_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.STRING, 1);

  Uint8List _thing;
  static const int THING = 1;


  testBinary_args();

  Uint8List get thing => this._thing;

  set thing(Uint8List thing) {
    this._thing = thing;
  }

  bool isSetThing() => this.thing != null;

  unsetThing() {
    this.thing = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as Uint8List;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.STRING) {
            this.thing = iprot.readBinary();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.thing != null) {
      oprot.writeFieldBegin(_THING_FIELD_DESC);
      oprot.writeBinary(this.thing);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testBinary_args(');

    ret.write('thing:');
    if (this.thing == null) {
      ret.write('null');
    } else {
      ret.write('BINARY');
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testBinary_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testBinary_args clone({
    Uint8List thing,
  }) {
    return testBinary_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testBinary_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testBinary_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.STRING, 0);

  Uint8List _success;
  static const int SUCCESS = 0;


  testBinary_result();

  Uint8List get success => this._success;

  set success(Uint8List success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Uint8List;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.STRING) {
            this.success = iprot.readBinary();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testBinary_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write('BINARY');
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testBinary_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testBinary_result clone({
    Uint8List success,
  }) {
    return testBinary_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testStruct_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testStruct_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.STRUCT, 1);

  t_frugal_test.Xtruct _thing;
  static const int THING = 1;


  testStruct_args();

  t_frugal_test.Xtruct get thing => this._thing;

  set thing(t_frugal_test.Xtruct thing) {
    this._thing = thing;
  }

  bool isSetThing() => this.thing != null;

  unsetThing() {
    this.thing = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as t_frugal_test.Xtruct;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.STRUCT) {
            this.thing = t_frugal_test.Xtruct();
            thing.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.thing != null) {
      oprot.writeFieldBegin(_THING_FIELD_DESC);
      this.thing.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testStruct_args(');

    ret.write('thing:');
    if (this.thing == null) {
      ret.write('null');
    } else {
      ret.write(this.thing);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testStruct_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testStruct_args clone({
    t_frugal_test.Xtruct thing,
  }) {
    return testStruct_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testStruct_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testStruct_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.STRUCT, 0);

  t_frugal_test.Xtruct _success;
  static const int SUCCESS = 0;


  testStruct_result();

  t_frugal_test.Xtruct get success => this._success;

  set success(t_frugal_test.Xtruct success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as t_frugal_test.Xtruct;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.STRUCT) {
            this.success = t_frugal_test.Xtruct();
            success.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testStruct_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testStruct_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testStruct_result clone({
    t_frugal_test.Xtruct success,
  }) {
    return testStruct_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testNest_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testNest_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.STRUCT, 1);

  t_frugal_test.Xtruct2 _thing;
  static const int THING = 1;


  testNest_args();

  t_frugal_test.Xtruct2 get thing => this._thing;

  set thing(t_frugal_test.Xtruct2 thing) {
    this._thing = thing;
  }

  bool isSetThing() => this.thing != null;

  unsetThing() {
    this.thing = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as t_frugal_test.Xtruct2;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.STRUCT) {
            this.thing = t_frugal_test.Xtruct2();
            thing.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.thing != null) {
      oprot.writeFieldBegin(_THING_FIELD_DESC);
      this.thing.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testNest_args(');

    ret.write('thing:');
    if (this.thing == null) {
      ret.write('null');
    } else {
      ret.write(this.thing);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testNest_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testNest_args clone({
    t_frugal_test.Xtruct2 thing,
  }) {
    return testNest_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testNest_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testNest_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.STRUCT, 0);

  t_frugal_test.Xtruct2 _success;
  static const int SUCCESS = 0;


  testNest_result();

  t_frugal_test.Xtruct2 get success => this._success;

  set success(t_frugal_test.Xtruct2 success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as t_frugal_test.Xtruct2;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.STRUCT) {
            this.success = t_frugal_test.Xtruct2();
            success.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testNest_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testNest_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testNest_result clone({
    t_frugal_test.Xtruct2 success,
  }) {
    return testNest_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testMap_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testMap_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.MAP, 1);

  Map<int, int> _thing;
  static const int THING = 1;


  testMap_args();

  Map<int, int> get thing => this._thing;

  set thing(Map<int, int> thing) {
    this._thing = thing;
  }

  bool isSetThing() => this.thing != null;

  unsetThing() {
    this.thing = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as Map<int, int>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.MAP) {
            thrift.TMap elem9 = iprot.readMapBegin();
            this.thing = Map<int, int>();
            for(int elem11 = 0; elem11 < elem9.length; ++elem11) {
              int elem12 = iprot.readI32();
              int elem10 = iprot.readI32();
              this.thing[elem12] = elem10;
            }
            iprot.readMapEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.thing != null) {
      oprot.writeFieldBegin(_THING_FIELD_DESC);
      oprot.writeMapBegin(thrift.TMap(thrift.TType.I32, thrift.TType.I32, this.thing.length));
      for(var elem13 in this.thing.keys) {
        oprot.writeI32(elem13);
        oprot.writeI32(thing[elem13]);
      }
      oprot.writeMapEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testMap_args(');

    ret.write('thing:');
    if (this.thing == null) {
      ret.write('null');
    } else {
      ret.write(this.thing);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testMap_args) {
      return DeepCollectionEquality().equals(this.thing, o.thing);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testMap_args clone({
    Map<int, int> thing,
  }) {
    return testMap_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testMap_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testMap_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.MAP, 0);

  Map<int, int> _success;
  static const int SUCCESS = 0;


  testMap_result();

  Map<int, int> get success => this._success;

  set success(Map<int, int> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Map<int, int>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.MAP) {
            thrift.TMap elem14 = iprot.readMapBegin();
            this.success = Map<int, int>();
            for(int elem16 = 0; elem16 < elem14.length; ++elem16) {
              int elem17 = iprot.readI32();
              int elem15 = iprot.readI32();
              this.success[elem17] = elem15;
            }
            iprot.readMapEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeMapBegin(thrift.TMap(thrift.TType.I32, thrift.TType.I32, this.success.length));
      for(var elem18 in this.success.keys) {
        oprot.writeI32(elem18);
        oprot.writeI32(success[elem18]);
      }
      oprot.writeMapEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testMap_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testMap_result) {
      return DeepCollectionEquality().equals(this.success, o.success);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testMap_result clone({
    Map<int, int> success,
  }) {
    return testMap_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testStringMap_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testStringMap_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.MAP, 1);

  Map<String, String> _thing;
  static const int THING = 1;


  testStringMap_args();

  Map<String, String> get thing => this._thing;

  set thing(Map<String, String> thing) {
    this._thing = thing;
  }

  bool isSetThing() => this.thing != null;

  unsetThing() {
    this.thing = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as Map<String, String>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.MAP) {
            thrift.TMap elem19 = iprot.readMapBegin();
            this.thing = Map<String, String>();
            for(int elem21 = 0; elem21 < elem19.length; ++elem21) {
              String elem22 = iprot.readString();
              String elem20 = iprot.readString();
              this.thing[elem22] = elem20;
            }
            iprot.readMapEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.thing != null) {
      oprot.writeFieldBegin(_THING_FIELD_DESC);
      oprot.writeMapBegin(thrift.TMap(thrift.TType.STRING, thrift.TType.STRING, this.thing.length));
      for(var elem23 in this.thing.keys) {
        oprot.writeString(elem23);
        oprot.writeString(thing[elem23]);
      }
      oprot.writeMapEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testStringMap_args(');

    ret.write('thing:');
    if (this.thing == null) {
      ret.write('null');
    } else {
      ret.write(this.thing);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testStringMap_args) {
      return DeepCollectionEquality().equals(this.thing, o.thing);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testStringMap_args clone({
    Map<String, String> thing,
  }) {
    return testStringMap_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testStringMap_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testStringMap_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.MAP, 0);

  Map<String, String> _success;
  static const int SUCCESS = 0;


  testStringMap_result();

  Map<String, String> get success => this._success;

  set success(Map<String, String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Map<String, String>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.MAP) {
            thrift.TMap elem24 = iprot.readMapBegin();
            this.success = Map<String, String>();
            for(int elem26 = 0; elem26 < elem24.length; ++elem26) {
              String elem27 = iprot.readString();
              String elem25 = iprot.readString();
              this.success[elem27] = elem25;
            }
            iprot.readMapEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeMapBegin(thrift.TMap(thrift.TType.STRING, thrift.TType.STRING, this.success.length));
      for(var elem28 in this.success.keys) {
        oprot.writeString(elem28);
        oprot.writeString(success[elem28]);
      }
      oprot.writeMapEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testStringMap_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testStringMap_result) {
      return DeepCollectionEquality().equals(this.success, o.success);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testStringMap_result clone({
    Map<String, String> success,
  }) {
    return testStringMap_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testSet_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testSet_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.SET, 1);

  Set<int> _thing;
  static const int THING = 1;


  testSet_args();

  Set<int> get thing => this._thing;

  set thing(Set<int> thing) {
    this._thing = thing;
  }

  bool isSetThing() => this.thing != null;

  unsetThing() {
    this.thing = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as Set<int>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.SET) {
            thrift.TSet elem29 = iprot.readSetBegin();
            this.thing = Set<int>();
            for(int elem31 = 0; elem31 < elem29.length; ++elem31) {
              int elem30 = iprot.readI32();
              this.thing.add(elem30);
            }
            iprot.readSetEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.thing != null) {
      oprot.writeFieldBegin(_THING_FIELD_DESC);
      oprot.writeSetBegin(thrift.TSet(thrift.TType.I32, this.thing.length));
      for(var elem32 in this.thing) {
        oprot.writeI32(elem32);
      }
      oprot.writeSetEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testSet_args(');

    ret.write('thing:');
    if (this.thing == null) {
      ret.write('null');
    } else {
      ret.write(this.thing);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testSet_args) {
      return DeepCollectionEquality().equals(this.thing, o.thing);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testSet_args clone({
    Set<int> thing,
  }) {
    return testSet_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testSet_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testSet_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.SET, 0);

  Set<int> _success;
  static const int SUCCESS = 0;


  testSet_result();

  Set<int> get success => this._success;

  set success(Set<int> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Set<int>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.SET) {
            thrift.TSet elem33 = iprot.readSetBegin();
            this.success = Set<int>();
            for(int elem35 = 0; elem35 < elem33.length; ++elem35) {
              int elem34 = iprot.readI32();
              this.success.add(elem34);
            }
            iprot.readSetEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeSetBegin(thrift.TSet(thrift.TType.I32, this.success.length));
      for(var elem36 in this.success) {
        oprot.writeI32(elem36);
      }
      oprot.writeSetEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testSet_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testSet_result) {
      return DeepCollectionEquality().equals(this.success, o.success);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testSet_result clone({
    Set<int> success,
  }) {
    return testSet_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testList_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testList_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.LIST, 1);

  List<int> _thing;
  static const int THING = 1;


  testList_args();

  List<int> get thing => this._thing;

  set thing(List<int> thing) {
    this._thing = thing;
  }

  bool isSetThing() => this.thing != null;

  unsetThing() {
    this.thing = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as List<int>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.LIST) {
            thrift.TList elem37 = iprot.readListBegin();
            this.thing = List<int>();
            for(int elem39 = 0; elem39 < elem37.length; ++elem39) {
              int elem38 = iprot.readI32();
              this.thing.add(elem38);
            }
            iprot.readListEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.thing != null) {
      oprot.writeFieldBegin(_THING_FIELD_DESC);
      oprot.writeListBegin(thrift.TList(thrift.TType.I32, this.thing.length));
      for(var elem40 in this.thing) {
        oprot.writeI32(elem40);
      }
      oprot.writeListEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testList_args(');

    ret.write('thing:');
    if (this.thing == null) {
      ret.write('null');
    } else {
      ret.write(this.thing);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testList_args) {
      return DeepCollectionEquality().equals(this.thing, o.thing);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testList_args clone({
    List<int> thing,
  }) {
    return testList_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testList_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testList_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.LIST, 0);

  List<int> _success;
  static const int SUCCESS = 0;


  testList_result();

  List<int> get success => this._success;

  set success(List<int> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as List<int>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.LIST) {
            thrift.TList elem41 = iprot.readListBegin();
            this.success = List<int>();
            for(int elem43 = 0; elem43 < elem41.length; ++elem43) {
              int elem42 = iprot.readI32();
              this.success.add(elem42);
            }
            iprot.readListEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeListBegin(thrift.TList(thrift.TType.I32, this.success.length));
      for(var elem44 in this.success) {
        oprot.writeI32(elem44);
      }
      oprot.writeListEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testList_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testList_result) {
      return DeepCollectionEquality().equals(this.success, o.success);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testList_result clone({
    List<int> success,
  }) {
    return testList_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testEnum_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testEnum_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.I32, 1);

  /// [t_frugal_test.Numberz]
  int _thing;
  static const int THING = 1;

  bool __isset_thing = false;

  testEnum_args();

  /// [t_frugal_test.Numberz]
  int get thing => this._thing;

  /// [t_frugal_test.Numberz]
  set thing(int thing) {
    this._thing = thing;
    this.__isset_thing = true;
  }

  bool isSetThing() => this.__isset_thing;

  unsetThing() {
    this.__isset_thing = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.I32) {
            this.thing = t_frugal_test.deserializeNumberz(iprot.readI32());
            this.__isset_thing = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_THING_FIELD_DESC);
    oprot.writeI32(t_frugal_test.serializeNumberz(this.thing));
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testEnum_args(');

    ret.write('thing:');
    String thing_name = t_frugal_test.Numberz.VALUES_TO_NAMES[this.thing];
    if (thing_name != null) {
      ret.write(thing_name);
      ret.write(' (');
    }
    ret.write(this.thing);
    if (thing_name != null) {
      ret.write(')');
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testEnum_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testEnum_args clone({
    int thing,
  }) {
    return testEnum_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testEnum_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testEnum_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.I32, 0);

  /// [t_frugal_test.Numberz]
  int _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  testEnum_result();

  /// [t_frugal_test.Numberz]
  int get success => this._success;

  /// [t_frugal_test.Numberz]
  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.I32) {
            this.success = t_frugal_test.deserializeNumberz(iprot.readI32());
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
    oprot.writeI32(t_frugal_test.serializeNumberz(this.success));
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testEnum_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      String success_name = t_frugal_test.Numberz.VALUES_TO_NAMES[this.success];
      if (success_name != null) {
        ret.write(success_name);
        ret.write(' (');
      }
      ret.write(this.success);
      if (success_name != null) {
        ret.write(')');
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testEnum_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testEnum_result clone({
    int success,
  }) {
    return testEnum_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testTypedef_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testTypedef_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.I64, 1);

  int _thing = 0;
  static const int THING = 1;

  bool __isset_thing = false;

  testTypedef_args();

  int get thing => this._thing;

  set thing(int thing) {
    this._thing = thing;
    this.__isset_thing = true;
  }

  bool isSetThing() => this.__isset_thing;

  unsetThing() {
    this.__isset_thing = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.I64) {
            this.thing = iprot.readI64();
            this.__isset_thing = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_THING_FIELD_DESC);
    oprot.writeI64(this.thing);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testTypedef_args(');

    ret.write('thing:');
    ret.write(this.thing);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testTypedef_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  testTypedef_args clone({
    int thing,
  }) {
    return testTypedef_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testTypedef_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testTypedef_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.I64, 0);

  int _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  testTypedef_result();

  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testTypedef_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      ret.write(this.success);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testTypedef_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testTypedef_result clone({
    int success,
  }) {
    return testTypedef_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testMapMap_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testMapMap_args');
  static final thrift.TField _HELLO_FIELD_DESC = thrift.TField('hello', thrift.TType.I32, 1);

  int _hello = 0;
  static const int HELLO = 1;

  bool __isset_hello = false;

  testMapMap_args();

  int get hello => this._hello;

  set hello(int hello) {
    this._hello = hello;
    this.__isset_hello = true;
  }

  bool isSetHello() => this.__isset_hello;

  unsetHello() {
    this.__isset_hello = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case HELLO:
        return this.hello;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case HELLO:
        if (value == null) {
          unsetHello();
        } else {
          this.hello = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case HELLO:
        return isSetHello();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case HELLO:
          if (field.type == thrift.TType.I32) {
            this.hello = iprot.readI32();
            this.__isset_hello = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_HELLO_FIELD_DESC);
    oprot.writeI32(this.hello);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testMapMap_args(');

    ret.write('hello:');
    ret.write(this.hello);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testMapMap_args) {
      return this.hello == o.hello;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.hello.hashCode;
    return value;
  }

  testMapMap_args clone({
    int hello,
  }) {
    return testMapMap_args()
      ..hello = hello ?? this.hello;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testMapMap_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testMapMap_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.MAP, 0);

  Map<int, Map<int, int>> _success;
  static const int SUCCESS = 0;


  testMapMap_result();

  Map<int, Map<int, int>> get success => this._success;

  set success(Map<int, Map<int, int>> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Map<int, Map<int, int>>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.MAP) {
            thrift.TMap elem45 = iprot.readMapBegin();
            this.success = Map<int, Map<int, int>>();
            for(int elem51 = 0; elem51 < elem45.length; ++elem51) {
              int elem52 = iprot.readI32();
              thrift.TMap elem47 = iprot.readMapBegin();
              Map<int, int> elem46 = Map<int, int>();
              for(int elem49 = 0; elem49 < elem47.length; ++elem49) {
                int elem50 = iprot.readI32();
                int elem48 = iprot.readI32();
                elem46[elem50] = elem48;
              }
              iprot.readMapEnd();
              this.success[elem52] = elem46;
            }
            iprot.readMapEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeMapBegin(thrift.TMap(thrift.TType.I32, thrift.TType.MAP, this.success.length));
      for(var elem53 in this.success.keys) {
        oprot.writeI32(elem53);
        oprot.writeMapBegin(thrift.TMap(thrift.TType.I32, thrift.TType.I32, success[elem53].length));
        for(var elem54 in success[elem53].keys) {
          oprot.writeI32(elem54);
          oprot.writeI32(success[elem53][elem54]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeMapEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testMapMap_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testMapMap_result) {
      return DeepCollectionEquality().equals(this.success, o.success);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testMapMap_result clone({
    Map<int, Map<int, int>> success,
  }) {
    return testMapMap_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class TestUppercaseMethod_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('TestUppercaseMethod_args');
  static final thrift.TField _THING_FIELD_DESC = thrift.TField('thing', thrift.TType.BOOL, 1);

  bool _thing = false;
  static const int THING = 1;

  bool __isset_thing = false;

  TestUppercaseMethod_args();

  bool get thing => this._thing;

  set thing(bool thing) {
    this._thing = thing;
    this.__isset_thing = true;
  }

  bool isSetThing() => this.__isset_thing;

  unsetThing() {
    this.__isset_thing = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case THING:
        return this.thing;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case THING:
        if (value == null) {
          unsetThing();
        } else {
          this.thing = value as bool;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case THING:
        return isSetThing();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case THING:
          if (field.type == thrift.TType.BOOL) {
            this.thing = iprot.readBool();
            this.__isset_thing = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_THING_FIELD_DESC);
    oprot.writeBool(this.thing);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('TestUppercaseMethod_args(');

    ret.write('thing:');
    ret.write(this.thing);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is TestUppercaseMethod_args) {
      return this.thing == o.thing;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.thing.hashCode;
    return value;
  }

  TestUppercaseMethod_args clone({
    bool thing,
  }) {
    return TestUppercaseMethod_args()
      ..thing = thing ?? this.thing;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class TestUppercaseMethod_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('TestUppercaseMethod_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.BOOL, 0);

  bool _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  TestUppercaseMethod_result();

  bool get success => this._success;

  set success(bool success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as bool;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('TestUppercaseMethod_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      ret.write(this.success);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is TestUppercaseMethod_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  TestUppercaseMethod_result clone({
    bool success,
  }) {
    return TestUppercaseMethod_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testInsanity_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testInsanity_args');
  static final thrift.TField _ARGUMENT_FIELD_DESC = thrift.TField('argument', thrift.TType.STRUCT, 1);

  t_frugal_test.Insanity _argument;
  static const int ARGUMENT = 1;


  testInsanity_args();

  t_frugal_test.Insanity get argument => this._argument;

  set argument(t_frugal_test.Insanity argument) {
    this._argument = argument;
  }

  bool isSetArgument() => this.argument != null;

  unsetArgument() {
    this.argument = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ARGUMENT:
        return this.argument;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ARGUMENT:
        if (value == null) {
          unsetArgument();
        } else {
          this.argument = value as t_frugal_test.Insanity;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ARGUMENT:
        return isSetArgument();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case ARGUMENT:
          if (field.type == thrift.TType.STRUCT) {
            this.argument = t_frugal_test.Insanity();
            argument.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.argument != null) {
      oprot.writeFieldBegin(_ARGUMENT_FIELD_DESC);
      this.argument.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testInsanity_args(');

    ret.write('argument:');
    if (this.argument == null) {
      ret.write('null');
    } else {
      ret.write(this.argument);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testInsanity_args) {
      return this.argument == o.argument;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.argument.hashCode;
    return value;
  }

  testInsanity_args clone({
    t_frugal_test.Insanity argument,
  }) {
    return testInsanity_args()
      ..argument = argument ?? this.argument;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testInsanity_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testInsanity_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.MAP, 0);

  Map<int, Map<int, t_frugal_test.Insanity>> _success;
  static const int SUCCESS = 0;


  testInsanity_result();

  Map<int, Map<int, t_frugal_test.Insanity>> get success => this._success;

  set success(Map<int, Map<int, t_frugal_test.Insanity>> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Map<int, Map<int, t_frugal_test.Insanity>>;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.MAP) {
            thrift.TMap elem55 = iprot.readMapBegin();
            this.success = Map<int, Map<int, t_frugal_test.Insanity>>();
            for(int elem61 = 0; elem61 < elem55.length; ++elem61) {
              int elem62 = iprot.readI64();
              thrift.TMap elem57 = iprot.readMapBegin();
              Map<int, t_frugal_test.Insanity> elem56 = Map<int, t_frugal_test.Insanity>();
              for(int elem59 = 0; elem59 < elem57.length; ++elem59) {
                int elem60 = t_frugal_test.deserializeNumberz(iprot.readI32());
                t_frugal_test.Insanity elem58 = t_frugal_test.Insanity();
                elem58.read(iprot);
                elem56[elem60] = elem58;
              }
              iprot.readMapEnd();
              this.success[elem62] = elem56;
            }
            iprot.readMapEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeMapBegin(thrift.TMap(thrift.TType.I64, thrift.TType.MAP, this.success.length));
      for(var elem63 in this.success.keys) {
        oprot.writeI64(elem63);
        oprot.writeMapBegin(thrift.TMap(thrift.TType.I32, thrift.TType.STRUCT, success[elem63].length));
        for(var elem64 in success[elem63].keys) {
    oprot.writeI32(t_frugal_test.serializeNumberz(elem64));
          success[elem63][elem64].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeMapEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testInsanity_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testInsanity_result) {
      return DeepCollectionEquality().equals(this.success, o.success);
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testInsanity_result clone({
    Map<int, Map<int, t_frugal_test.Insanity>> success,
  }) {
    return testInsanity_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testMulti_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testMulti_args');
  static final thrift.TField _ARG0_FIELD_DESC = thrift.TField('arg0', thrift.TType.BYTE, 1);
  static final thrift.TField _ARG1_FIELD_DESC = thrift.TField('arg1', thrift.TType.I32, 2);
  static final thrift.TField _ARG2_FIELD_DESC = thrift.TField('arg2', thrift.TType.I64, 3);
  static final thrift.TField _ARG3_FIELD_DESC = thrift.TField('arg3', thrift.TType.MAP, 4);
  static final thrift.TField _ARG4_FIELD_DESC = thrift.TField('arg4', thrift.TType.I32, 5);
  static final thrift.TField _ARG5_FIELD_DESC = thrift.TField('arg5', thrift.TType.I64, 6);

  int _arg0 = 0;
  static const int ARG0 = 1;
  int _arg1 = 0;
  static const int ARG1 = 2;
  int _arg2 = 0;
  static const int ARG2 = 3;
  Map<int, String> _arg3;
  static const int ARG3 = 4;
  /// [t_frugal_test.Numberz]
  int _arg4;
  static const int ARG4 = 5;
  int _arg5 = 0;
  static const int ARG5 = 6;

  bool __isset_arg0 = false;
  bool __isset_arg1 = false;
  bool __isset_arg2 = false;
  bool __isset_arg4 = false;
  bool __isset_arg5 = false;

  testMulti_args();

  int get arg0 => this._arg0;

  set arg0(int arg0) {
    this._arg0 = arg0;
    this.__isset_arg0 = true;
  }

  bool isSetArg0() => this.__isset_arg0;

  unsetArg0() {
    this.__isset_arg0 = false;
  }

  int get arg1 => this._arg1;

  set arg1(int arg1) {
    this._arg1 = arg1;
    this.__isset_arg1 = true;
  }

  bool isSetArg1() => this.__isset_arg1;

  unsetArg1() {
    this.__isset_arg1 = false;
  }

  int get arg2 => this._arg2;

  set arg2(int arg2) {
    this._arg2 = arg2;
    this.__isset_arg2 = true;
  }

  bool isSetArg2() => this.__isset_arg2;

  unsetArg2() {
    this.__isset_arg2 = false;
  }

  Map<int, String> get arg3 => this._arg3;

  set arg3(Map<int, String> arg3) {
    this._arg3 = arg3;
  }

  bool isSetArg3() => this.arg3 != null;

  unsetArg3() {
    this.arg3 = null;
  }

  /// [t_frugal_test.Numberz]
  int get arg4 => this._arg4;

  /// [t_frugal_test.Numberz]
  set arg4(int arg4) {
    this._arg4 = arg4;
    this.__isset_arg4 = true;
  }

  bool isSetArg4() => this.__isset_arg4;

  unsetArg4() {
    this.__isset_arg4 = false;
  }

  int get arg5 => this._arg5;

  set arg5(int arg5) {
    this._arg5 = arg5;
    this.__isset_arg5 = true;
  }

  bool isSetArg5() => this.__isset_arg5;

  unsetArg5() {
    this.__isset_arg5 = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ARG0:
        return this.arg0;
      case ARG1:
        return this.arg1;
      case ARG2:
        return this.arg2;
      case ARG3:
        return this.arg3;
      case ARG4:
        return this.arg4;
      case ARG5:
        return this.arg5;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ARG0:
        if (value == null) {
          unsetArg0();
        } else {
          this.arg0 = value as int;
        }
        break;

      case ARG1:
        if (value == null) {
          unsetArg1();
        } else {
          this.arg1 = value as int;
        }
        break;

      case ARG2:
        if (value == null) {
          unsetArg2();
        } else {
          this.arg2 = value as int;
        }
        break;

      case ARG3:
        if (value == null) {
          unsetArg3();
        } else {
          this.arg3 = value as Map<int, String>;
        }
        break;

      case ARG4:
        if (value == null) {
          unsetArg4();
        } else {
          this.arg4 = value as int;
        }
        break;

      case ARG5:
        if (value == null) {
          unsetArg5();
        } else {
          this.arg5 = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ARG0:
        return isSetArg0();
      case ARG1:
        return isSetArg1();
      case ARG2:
        return isSetArg2();
      case ARG3:
        return isSetArg3();
      case ARG4:
        return isSetArg4();
      case ARG5:
        return isSetArg5();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case ARG0:
          if (field.type == thrift.TType.BYTE) {
            this.arg0 = iprot.readByte();
            this.__isset_arg0 = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ARG1:
          if (field.type == thrift.TType.I32) {
            this.arg1 = iprot.readI32();
            this.__isset_arg1 = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ARG2:
          if (field.type == thrift.TType.I64) {
            this.arg2 = iprot.readI64();
            this.__isset_arg2 = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ARG3:
          if (field.type == thrift.TType.MAP) {
            thrift.TMap elem65 = iprot.readMapBegin();
            this.arg3 = Map<int, String>();
            for(int elem67 = 0; elem67 < elem65.length; ++elem67) {
              int elem68 = iprot.readI16();
              String elem66 = iprot.readString();
              this.arg3[elem68] = elem66;
            }
            iprot.readMapEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ARG4:
          if (field.type == thrift.TType.I32) {
            this.arg4 = t_frugal_test.deserializeNumberz(iprot.readI32());
            this.__isset_arg4 = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ARG5:
          if (field.type == thrift.TType.I64) {
            this.arg5 = iprot.readI64();
            this.__isset_arg5 = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ARG0_FIELD_DESC);
    oprot.writeByte(this.arg0);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ARG1_FIELD_DESC);
    oprot.writeI32(this.arg1);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ARG2_FIELD_DESC);
    oprot.writeI64(this.arg2);
    oprot.writeFieldEnd();
    if (this.arg3 != null) {
      oprot.writeFieldBegin(_ARG3_FIELD_DESC);
      oprot.writeMapBegin(thrift.TMap(thrift.TType.I16, thrift.TType.STRING, this.arg3.length));
      for(var elem69 in this.arg3.keys) {
        oprot.writeI16(elem69);
        oprot.writeString(arg3[elem69]);
      }
      oprot.writeMapEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_ARG4_FIELD_DESC);
    oprot.writeI32(t_frugal_test.serializeNumberz(this.arg4));
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ARG5_FIELD_DESC);
    oprot.writeI64(this.arg5);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testMulti_args(');

    ret.write('arg0:');
    ret.write(this.arg0);

    ret.write(', ');
    ret.write('arg1:');
    ret.write(this.arg1);

    ret.write(', ');
    ret.write('arg2:');
    ret.write(this.arg2);

    ret.write(', ');
    ret.write('arg3:');
    if (this.arg3 == null) {
      ret.write('null');
    } else {
      ret.write(this.arg3);
    }

    ret.write(', ');
    ret.write('arg4:');
    String arg4_name = t_frugal_test.Numberz.VALUES_TO_NAMES[this.arg4];
    if (arg4_name != null) {
      ret.write(arg4_name);
      ret.write(' (');
    }
    ret.write(this.arg4);
    if (arg4_name != null) {
      ret.write(')');
    }

    ret.write(', ');
    ret.write('arg5:');
    ret.write(this.arg5);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testMulti_args) {
      return this.arg0 == o.arg0 &&
        this.arg1 == o.arg1 &&
        this.arg2 == o.arg2 &&
        DeepCollectionEquality().equals(this.arg3, o.arg3) &&
        this.arg4 == o.arg4 &&
        this.arg5 == o.arg5;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.arg0.hashCode;
    value = (value * 31) ^ this.arg1.hashCode;
    value = (value * 31) ^ this.arg2.hashCode;
    value = (value * 31) ^ this.arg3.hashCode;
    value = (value * 31) ^ this.arg4.hashCode;
    value = (value * 31) ^ this.arg5.hashCode;
    return value;
  }

  testMulti_args clone({
    int arg0,
    int arg1,
    int arg2,
    Map<int, String> arg3,
    int arg4,
    int arg5,
  }) {
    return testMulti_args()
      ..arg0 = arg0 ?? this.arg0
      ..arg1 = arg1 ?? this.arg1
      ..arg2 = arg2 ?? this.arg2
      ..arg3 = arg3 ?? this.arg3
      ..arg4 = arg4 ?? this.arg4
      ..arg5 = arg5 ?? this.arg5;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testMulti_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testMulti_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.STRUCT, 0);

  t_frugal_test.Xtruct _success;
  static const int SUCCESS = 0;


  testMulti_result();

  t_frugal_test.Xtruct get success => this._success;

  set success(t_frugal_test.Xtruct success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as t_frugal_test.Xtruct;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.STRUCT) {
            this.success = t_frugal_test.Xtruct();
            success.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testMulti_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testMulti_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testMulti_result clone({
    t_frugal_test.Xtruct success,
  }) {
    return testMulti_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testException_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testException_args');
  static final thrift.TField _ARG_FIELD_DESC = thrift.TField('arg', thrift.TType.STRING, 1);

  String _arg;
  static const int ARG = 1;


  testException_args();

  String get arg => this._arg;

  set arg(String arg) {
    this._arg = arg;
  }

  bool isSetArg() => this.arg != null;

  unsetArg() {
    this.arg = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ARG:
        return this.arg;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ARG:
        if (value == null) {
          unsetArg();
        } else {
          this.arg = value as String;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ARG:
        return isSetArg();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case ARG:
          if (field.type == thrift.TType.STRING) {
            this.arg = iprot.readString();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.arg != null) {
      oprot.writeFieldBegin(_ARG_FIELD_DESC);
      oprot.writeString(this.arg);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testException_args(');

    ret.write('arg:');
    if (this.arg == null) {
      ret.write('null');
    } else {
      ret.write(this.arg);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testException_args) {
      return this.arg == o.arg;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.arg.hashCode;
    return value;
  }

  testException_args clone({
    String arg,
  }) {
    return testException_args()
      ..arg = arg ?? this.arg;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testException_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testException_result');
  static final thrift.TField _ERR1_FIELD_DESC = thrift.TField('err1', thrift.TType.STRUCT, 1);

  t_frugal_test.Xception _err1;
  static const int ERR1 = 1;


  testException_result();

  t_frugal_test.Xception get err1 => this._err1;

  set err1(t_frugal_test.Xception err1) {
    this._err1 = err1;
  }

  bool isSetErr1() => this.err1 != null;

  unsetErr1() {
    this.err1 = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ERR1:
        return this.err1;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ERR1:
        if (value == null) {
          unsetErr1();
        } else {
          this.err1 = value as t_frugal_test.Xception;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ERR1:
        return isSetErr1();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case ERR1:
          if (field.type == thrift.TType.STRUCT) {
            this.err1 = t_frugal_test.Xception();
            err1.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetErr1() && this.err1 != null) {
      oprot.writeFieldBegin(_ERR1_FIELD_DESC);
      this.err1.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testException_result(');

    if (isSetErr1()) {
      ret.write('err1:');
      if (this.err1 == null) {
        ret.write('null');
      } else {
        ret.write(this.err1);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testException_result) {
      return this.err1 == o.err1;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.err1.hashCode;
    return value;
  }

  testException_result clone({
    t_frugal_test.Xception err1,
  }) {
    return testException_result()
      ..err1 = err1 ?? this.err1;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testMultiException_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testMultiException_args');
  static final thrift.TField _ARG0_FIELD_DESC = thrift.TField('arg0', thrift.TType.STRING, 1);
  static final thrift.TField _ARG1_FIELD_DESC = thrift.TField('arg1', thrift.TType.STRING, 2);

  String _arg0;
  static const int ARG0 = 1;
  String _arg1;
  static const int ARG1 = 2;


  testMultiException_args();

  String get arg0 => this._arg0;

  set arg0(String arg0) {
    this._arg0 = arg0;
  }

  bool isSetArg0() => this.arg0 != null;

  unsetArg0() {
    this.arg0 = null;
  }

  String get arg1 => this._arg1;

  set arg1(String arg1) {
    this._arg1 = arg1;
  }

  bool isSetArg1() => this.arg1 != null;

  unsetArg1() {
    this.arg1 = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ARG0:
        return this.arg0;
      case ARG1:
        return this.arg1;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ARG0:
        if (value == null) {
          unsetArg0();
        } else {
          this.arg0 = value as String;
        }
        break;

      case ARG1:
        if (value == null) {
          unsetArg1();
        } else {
          this.arg1 = value as String;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ARG0:
        return isSetArg0();
      case ARG1:
        return isSetArg1();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case ARG0:
          if (field.type == thrift.TType.STRING) {
            this.arg0 = iprot.readString();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ARG1:
          if (field.type == thrift.TType.STRING) {
            this.arg1 = iprot.readString();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.arg0 != null) {
      oprot.writeFieldBegin(_ARG0_FIELD_DESC);
      oprot.writeString(this.arg0);
      oprot.writeFieldEnd();
    }
    if (this.arg1 != null) {
      oprot.writeFieldBegin(_ARG1_FIELD_DESC);
      oprot.writeString(this.arg1);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testMultiException_args(');

    ret.write('arg0:');
    if (this.arg0 == null) {
      ret.write('null');
    } else {
      ret.write(this.arg0);
    }

    ret.write(', ');
    ret.write('arg1:');
    if (this.arg1 == null) {
      ret.write('null');
    } else {
      ret.write(this.arg1);
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testMultiException_args) {
      return this.arg0 == o.arg0 &&
        this.arg1 == o.arg1;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.arg0.hashCode;
    value = (value * 31) ^ this.arg1.hashCode;
    return value;
  }

  testMultiException_args clone({
    String arg0,
    String arg1,
  }) {
    return testMultiException_args()
      ..arg0 = arg0 ?? this.arg0
      ..arg1 = arg1 ?? this.arg1;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testMultiException_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testMultiException_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.STRUCT, 0);
  static final thrift.TField _ERR1_FIELD_DESC = thrift.TField('err1', thrift.TType.STRUCT, 1);
  static final thrift.TField _ERR2_FIELD_DESC = thrift.TField('err2', thrift.TType.STRUCT, 2);

  t_frugal_test.Xtruct _success;
  static const int SUCCESS = 0;
  t_frugal_test.Xception _err1;
  static const int ERR1 = 1;
  t_frugal_test.Xception2 _err2;
  static const int ERR2 = 2;


  testMultiException_result();

  t_frugal_test.Xtruct get success => this._success;

  set success(t_frugal_test.Xtruct success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  t_frugal_test.Xception get err1 => this._err1;

  set err1(t_frugal_test.Xception err1) {
    this._err1 = err1;
  }

  bool isSetErr1() => this.err1 != null;

  unsetErr1() {
    this.err1 = null;
  }

  t_frugal_test.Xception2 get err2 => this._err2;

  set err2(t_frugal_test.Xception2 err2) {
    this._err2 = err2;
  }

  bool isSetErr2() => this.err2 != null;

  unsetErr2() {
    this.err2 = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case ERR1:
        return this.err1;
      case ERR2:
        return this.err2;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as t_frugal_test.Xtruct;
        }
        break;

      case ERR1:
        if (value == null) {
          unsetErr1();
        } else {
          this.err1 = value as t_frugal_test.Xception;
        }
        break;

      case ERR2:
        if (value == null) {
          unsetErr2();
        } else {
          this.err2 = value as t_frugal_test.Xception2;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR1:
        return isSetErr1();
      case ERR2:
        return isSetErr2();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.STRUCT) {
            this.success = t_frugal_test.Xtruct();
            success.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ERR1:
          if (field.type == thrift.TType.STRUCT) {
            this.err1 = t_frugal_test.Xception();
            err1.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ERR2:
          if (field.type == thrift.TType.STRUCT) {
            this.err2 = t_frugal_test.Xception2();
            err2.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    if (isSetErr1() && this.err1 != null) {
      oprot.writeFieldBegin(_ERR1_FIELD_DESC);
      this.err1.write(oprot);
      oprot.writeFieldEnd();
    }
    if (isSetErr2() && this.err2 != null) {
      oprot.writeFieldBegin(_ERR2_FIELD_DESC);
      this.err2.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testMultiException_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write(this.success);
      }
    }

    if (isSetErr1()) {
      ret.write(', ');
      ret.write('err1:');
      if (this.err1 == null) {
        ret.write('null');
      } else {
        ret.write(this.err1);
      }
    }

    if (isSetErr2()) {
      ret.write(', ');
      ret.write('err2:');
      if (this.err2 == null) {
        ret.write('null');
      } else {
        ret.write(this.err2);
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testMultiException_result) {
      return this.success == o.success &&
        this.err1 == o.err1 &&
        this.err2 == o.err2;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    value = (value * 31) ^ this.err1.hashCode;
    value = (value * 31) ^ this.err2.hashCode;
    return value;
  }

  testMultiException_result clone({
    t_frugal_test.Xtruct success,
    t_frugal_test.Xception err1,
    t_frugal_test.Xception2 err2,
  }) {
    return testMultiException_result()
      ..success = success ?? this.success
      ..err1 = err1 ?? this.err1
      ..err2 = err2 ?? this.err2;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testUncaughtException_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testUncaughtException_args');



  testUncaughtException_args();

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testUncaughtException_args(');

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    return o is testUncaughtException_args;
  }

  @override
  int get hashCode {
    var value = 17;
    return value;
  }

  testUncaughtException_args clone() {
    return testUncaughtException_args();
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testUncaughtException_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testUncaughtException_result');



  testUncaughtException_result();

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testUncaughtException_result(');

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    return o is testUncaughtException_result;
  }

  @override
  int get hashCode {
    var value = 17;
    return value;
  }

  testUncaughtException_result clone() {
    return testUncaughtException_result();
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testUncheckedTApplicationException_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testUncheckedTApplicationException_args');



  testUncheckedTApplicationException_args();

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testUncheckedTApplicationException_args(');

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    return o is testUncheckedTApplicationException_args;
  }

  @override
  int get hashCode {
    var value = 17;
    return value;
  }

  testUncheckedTApplicationException_args clone() {
    return testUncheckedTApplicationException_args();
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testUncheckedTApplicationException_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testUncheckedTApplicationException_result');



  testUncheckedTApplicationException_result();

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testUncheckedTApplicationException_result(');

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    return o is testUncheckedTApplicationException_result;
  }

  @override
  int get hashCode {
    var value = 17;
    return value;
  }

  testUncheckedTApplicationException_result clone() {
    return testUncheckedTApplicationException_result();
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testRequestTooLarge_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testRequestTooLarge_args');
  static final thrift.TField _REQUEST_FIELD_DESC = thrift.TField('request', thrift.TType.STRING, 1);

  Uint8List _request;
  static const int REQUEST = 1;


  testRequestTooLarge_args();

  Uint8List get request => this._request;

  set request(Uint8List request) {
    this._request = request;
  }

  bool isSetRequest() => this.request != null;

  unsetRequest() {
    this.request = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return this.request;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          this.request = value as Uint8List;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return isSetRequest();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case REQUEST:
          if (field.type == thrift.TType.STRING) {
            this.request = iprot.readBinary();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.request != null) {
      oprot.writeFieldBegin(_REQUEST_FIELD_DESC);
      oprot.writeBinary(this.request);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testRequestTooLarge_args(');

    ret.write('request:');
    if (this.request == null) {
      ret.write('null');
    } else {
      ret.write('BINARY');
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testRequestTooLarge_args) {
      return this.request == o.request;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.request.hashCode;
    return value;
  }

  testRequestTooLarge_args clone({
    Uint8List request,
  }) {
    return testRequestTooLarge_args()
      ..request = request ?? this.request;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testRequestTooLarge_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testRequestTooLarge_result');



  testRequestTooLarge_result();

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testRequestTooLarge_result(');

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    return o is testRequestTooLarge_result;
  }

  @override
  int get hashCode {
    var value = 17;
    return value;
  }

  testRequestTooLarge_result clone() {
    return testRequestTooLarge_result();
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testResponseTooLarge_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testResponseTooLarge_args');
  static final thrift.TField _REQUEST_FIELD_DESC = thrift.TField('request', thrift.TType.STRING, 1);

  Uint8List _request;
  static const int REQUEST = 1;


  testResponseTooLarge_args();

  Uint8List get request => this._request;

  set request(Uint8List request) {
    this._request = request;
  }

  bool isSetRequest() => this.request != null;

  unsetRequest() {
    this.request = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return this.request;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          this.request = value as Uint8List;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQUEST:
        return isSetRequest();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case REQUEST:
          if (field.type == thrift.TType.STRING) {
            this.request = iprot.readBinary();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.request != null) {
      oprot.writeFieldBegin(_REQUEST_FIELD_DESC);
      oprot.writeBinary(this.request);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testResponseTooLarge_args(');

    ret.write('request:');
    if (this.request == null) {
      ret.write('null');
    } else {
      ret.write('BINARY');
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testResponseTooLarge_args) {
      return this.request == o.request;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.request.hashCode;
    return value;
  }

  testResponseTooLarge_args clone({
    Uint8List request,
  }) {
    return testResponseTooLarge_args()
      ..request = request ?? this.request;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testResponseTooLarge_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testResponseTooLarge_result');
  static final thrift.TField _SUCCESS_FIELD_DESC = thrift.TField('success', thrift.TType.STRING, 0);

  Uint8List _success;
  static const int SUCCESS = 0;


  testResponseTooLarge_result();

  Uint8List get success => this._success;

  set success(Uint8List success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Uint8List;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case SUCCESS:
          if (field.type == thrift.TType.STRING) {
            this.success = iprot.readBinary();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testResponseTooLarge_result(');

    if (isSetSuccess()) {
      ret.write('success:');
      if (this.success == null) {
        ret.write('null');
      } else {
        ret.write('BINARY');
      }
    }

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testResponseTooLarge_result) {
      return this.success == o.success;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.success.hashCode;
    return value;
  }

  testResponseTooLarge_result clone({
    Uint8List success,
  }) {
    return testResponseTooLarge_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
  }
}
// ignore: camel_case_types
class testOneway_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = thrift.TStruct('testOneway_args');
  static final thrift.TField _MILLISECONDS_TO_SLEEP_FIELD_DESC = thrift.TField('millisecondsToSleep', thrift.TType.I32, 1);

  int _millisecondsToSleep = 0;
  static const int MILLISECONDSTOSLEEP = 1;

  bool __isset_millisecondsToSleep = false;

  testOneway_args();

  int get millisecondsToSleep => this._millisecondsToSleep;

  set millisecondsToSleep(int millisecondsToSleep) {
    this._millisecondsToSleep = millisecondsToSleep;
    this.__isset_millisecondsToSleep = true;
  }

  bool isSetMillisecondsToSleep() => this.__isset_millisecondsToSleep;

  unsetMillisecondsToSleep() {
    this.__isset_millisecondsToSleep = false;
  }

  @override
  getFieldValue(int fieldID) {
    switch (fieldID) {
      case MILLISECONDSTOSLEEP:
        return this.millisecondsToSleep;
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case MILLISECONDSTOSLEEP:
        if (value == null) {
          unsetMillisecondsToSleep();
        } else {
          this.millisecondsToSleep = value as int;
        }
        break;

      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  @override
  bool isSet(int fieldID) {
    switch (fieldID) {
      case MILLISECONDSTOSLEEP:
        return isSetMillisecondsToSleep();
      default:
        throw ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  @override
  read(thrift.TProtocol iprot) {
    iprot.readStructBegin();
    for (thrift.TField field = iprot.readFieldBegin();
        field.type != thrift.TType.STOP;
        field = iprot.readFieldBegin()) {
      switch (field.id) {
        case MILLISECONDSTOSLEEP:
          if (field.type == thrift.TType.I32) {
            this.millisecondsToSleep = iprot.readI32();
            this.__isset_millisecondsToSleep = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_MILLISECONDS_TO_SLEEP_FIELD_DESC);
    oprot.writeI32(this.millisecondsToSleep);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer('testOneway_args(');

    ret.write('millisecondsToSleep:');
    ret.write(this.millisecondsToSleep);

    ret.write(')');

    return ret.toString();
  }

  @override
  bool operator ==(Object o) {
    if (o is testOneway_args) {
      return this.millisecondsToSleep == o.millisecondsToSleep;
    }
    return false;
  }

  @override
  int get hashCode {
    var value = 17;
    value = (value * 31) ^ this.millisecondsToSleep.hashCode;
    return value;
  }

  testOneway_args clone({
    int millisecondsToSleep,
  }) {
    return testOneway_args()
      ..millisecondsToSleep = millisecondsToSleep ?? this.millisecondsToSleep;
  }

  validate() {
    // check for required fields
  }
}
